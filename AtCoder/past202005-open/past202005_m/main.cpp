#include <bits/stdc++.h>
#define REP(i, n) for (int i = 0; (i) < (int)(n); ++(i))
#define REP3(i, m, n) for (int i = (m); (i) < (int)(n); ++(i))
#define REP_R(i, n) for (int i = (int)(n)-1; (i) >= 0; --(i))
#define REP3R(i, m, n) for (int i = (int)(n)-1; (i) >= (int)(m); --(i))
#define ALL(x) ::std::begin(x), ::std::end(x)
using namespace std;
using ll = long long;
using pi = pair<int, int>;

bool has_bit(ll n, ll i) {
    return (n & (1 << i)) > 0;
}

int64_t solve(int64_t N, int M, const std::vector<int64_t> &u, const std::vector<int64_t> &v, int64_t s, int K, std::vector<int64_t> &t) {
    // 辺の隣接リスト
    vector<vector<ll>> edges(N, vector<ll>());
    REP(i, M) {
        edges[u[i] - 1].push_back(v[i] - 1);
        edges[v[i] - 1].push_back(u[i] - 1);
    }

    REP(i, t.size()) {
        t[i]--;
    }

    s--;
    // 実装上t[K]=Sとしておく
    t.push_back(s);

    // Dist[k][l]:頂点T[k]から頂点T[l]までの移動コスト
    // vector<vector<ll>> Dist(K + 1, vector<ll>(K + 1, 1e18));
    vector<vector<ll>> Dist;
    const ll INF = 1e18;
    for (const ll &t1 : t) {
        // BFS(幅優先探索)
        vector<ll> dist(N, INF);
        deque<ll> que;
        que.push_back((ll)t1);
        dist[t1] = 0;
        while (que.size() > 0) {
            ll i = que.front();
            que.pop_front();
            for (const ll &j : edges[i]) {
                if (dist[j] == INF) {
                    dist[j] = dist[i] + 1;
                    que.push_back(j);
                }
            }
        }
        vector<ll> res;
        for (const ll &t2 : t) {
            res.push_back(dist[t2]);
        }
        Dist.push_back(res);
    }

    // 巡回セールスマン問題
    // const[n][i]:Tの中で訪れた頂点の集合がnで，
    // 最後にいる頂点がT[i]であるときのコスト最小値
    ll ALL = 1 << K;
    vector<vector<ll>> cost(ALL, vector<ll>(K, INF));
    // REP(i, Dist.size()) {
    //     cout << "dist size:" << Dist[i].size() << endl;
    //     REP(j, Dist[i].size()) {
    //         cout << Dist[i][j] << " ";
    //     }
    //     cout << endl;
    // }

    // cout << "ALL:" << ALL << endl;
    // cout << "K:" << K << endl;
    // cout << "dist size:" << Dist.size() << endl;
    // cout << "dist size:" << Dist[2].size() << endl;
    // 始点Sから各T[i]に移動した状態を初期状態とする
    REP(i, K) {
        // cout << "i:" << i << endl;

        ll n = (1 << i);
        // cout << n << endl;
        // cout << cost[n][i] << endl;
        // cout << Dist[0][i] << endl;
        cost[n][i] = Dist[K][i];
    }

    REP(n, ALL) {
        REP(i, K) {
            // iからjに移動する遷移を試す
            REP(j, K) {
                // すでに訪問済みか，同じ頂点は無視する
                if (has_bit(n, j) || i == j) {
                    continue;
                }
                // 事前計算したT[i]からT[j]への最小距離を使う
                cost[n | (1 << j)][j] = min(cost[n | (1 << j)][j], cost[n][i] + Dist[i][j]);
            }
        }
    }
    auto min = min_element(cost[ALL - 1].begin(), cost[ALL - 1].end());

    return *min;
}

// generated by oj-template v4.8.1 (https://github.com/online-judge-tools/template-generator)
int main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);
    int64_t N;
    int M;
    int64_t s;
    int K;
    std::cin >> N >> M;
    std::vector<int64_t> u(M), v(M);
    REP(i, M) {
        std::cin >> u[i] >> v[i];
    }
    std::cin >> s >> K;
    std::vector<int64_t> t(K);
    REP(i, K) {
        std::cin >> t[i];
    }
    auto ans = solve(N, M, u, v, s, K, t);

    std::cout << ans << '\n';
    return 0;
}
